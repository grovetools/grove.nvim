{
  "sections": {
    "configuration": {
      "title": "Configuration",
      "content": "This document provides instructions for installing, configuring, and using the keybindings for `grove-nvim`.",
      "subsections": [
        {
          "title": "1. Installation",
          "content": "The `grove-nvim` plugin requires the Grove ecosystem to be installed and available in your `PATH`.\n\n1.  **Install the plugin binary** using the Grove meta-tool:\n    ```bash\n    grove install grove-nvim\n    ```\n\n2.  **Add the plugin to your Neovim configuration.**\n\n    For `lazy.nvim`:\n    ```lua\n    { \"mattsolo1/grove-nvim\" }\n    ```\n\nThe plugin will be loaded automatically on startup."
        },
        {
          "title": "2. Configuration",
          "content": "### Plugin Setup\n\nThe `grove-nvim` plugin is designed to work after installation with no extra setup. It does not have or require a `setup()` function. Once loaded by your plugin manager, all commands and keybindings are available.\n\n### Statusline Integration\n\nThe plugin provides a status function to indicate when a background chat job is active. This is used for the `:GroveChatRun silent` command, which runs a job in the background and displays a spinner in the statusline instead of opening a terminal.\n\nThe function `require('grove-nvim').status()` returns a string containing a spinner animation and the text \"Grove\" when a job is running, and an empty string otherwise. It is implemented in `lua/grove-nvim/init.lua`.\n\n#### Lualine Example\n\nTo integrate with `lualine.nvim`, add the component to your configuration.\n\n\nThis configuration ensures the Grove component only appears in the statusline when a background chat job is active.",
          "code_blocks": [
            "-- ~/.config/nvim/lua/plugins/lualine.lua\n\nrequire('lualine').setup {\n  options = {\n    -- ... your other options\n  },\n  sections = {\n    -- ... other sections\n    lualine_x = {\n      -- Other components...\n      {\n        require('grove-nvim').status,\n        cond = function()\n          -- Only show the component when it's active\n          return require('grove-nvim').status() ~= ''\n        end,\n      },\n      'filetype',\n    },\n    -- ... other sections\n  },\n}"
          ]
        },
        {
          "title": "3. Keybindings",
          "content": "The following tables document the default keybindings provided by `grove-nvim`, sourced from `plugin/grove.lua`.\n\n### Plan Management\n\n| Keybinding       | Command                  | Description                        | Mode   |\n| ---------------- | ------------------------ | ---------------------------------- | ------ |\n| `\u003cleader\u003efp`     | `:GrovePlan`             | Open the Grove Plan picker         | Normal |\n| `\u003cleader\u003efpx`    | `:GrovePlanExtract`      | Extract a new plan from the buffer | Normal |\n| `\u003cleader\u003ejn`     | `:GroveAddJob`           | Add job to active plan (Form UI)   | Normal |\n| `\u003cleader\u003eji`     | `:GroveAddJobTUI`        | Add job to active plan (TUI)       | Normal |\n\n### Chat\n\n| Keybinding       | Command                  | Description                        | Mode   |\n| ---------------- | ------------------------ | ---------------------------------- | ------ |\n| `\u003cleader\u003efc`     | `:GroveChatRun`          | Run an interactive chat session    | Normal |\n\n### Target File Workflow\n\nThese keybindings operate on visually selected text and require a target file to be set with `:GroveSetTarget`.\n\n| Keybinding       | Command                  | Description                               | Mode   |\n| ---------------- | ------------------------ | ----------------------------------------- | ------ |\n| `\u003cleader\u003efq`     | `:'\u003c,'\u003eGroveText`        | Append selection and ask a question       | Visual |\n| `\u003cleader\u003efr`     | `:'\u003c,'\u003eGroveTextRun`     | Append selection, ask, and run chat       | Visual |"
        }
      ]
    },
    "examples": {
      "title": "Examples",
      "content": "This document provides practical examples for using `grove-nvim`, demonstrating its main workflows for AI-assisted development within Neovim.",
      "subsections": [
        {
          "title": "Example 1: Interactive Chat and Plan Creation",
          "content": "This example demonstrates starting with an interactive session in a markdown file and converting it into a Grove plan.\n\n1.  **Start an Interactive Chat Session**\n\n    The `:GroveChatRun` command runs an interactive `flow chat` session on the current buffer.\n\n    ```markdown\n    ---\n    title: \"Implement a new caching layer\"\n    ---\n\n    # Brainstorming: New Caching Layer\n\n    Let's design a caching layer for our application. It should use Redis and have a clear API for getting, setting, and invalidating cache keys.\n    ```\n\n    Running `:GroveChatRun` opens a new terminal split within Neovim. The content of the markdown file is used as the initial context. After the session, the file is updated with the full transcript.\n\n2.  **Convert the Chat into a Plan**\n\n    The `:GrovePlanExtract` command creates a development plan from the current buffer's content. It prompts for a plan name, suggesting one based on the `title` field from the markdown frontmatter. If no title is found, it uses the buffer's filename as a fallback.\n\n    ```\n    New Plan Name (from buffer): implement-a-new-caching-layer\n    ```\n\n3.  **Resulting Behavior**\n\n    After confirming the name, `grove-nvim` creates a new plan directory (e.g., `.grove/plans/implement-a-new-caching-layer/`). The content of the markdown file is used to create the first job in the plan, `010-implement-a-new-caching-layer.md`.\n\n#### Mechanism\n\n-   `:GroveChatRun` executes the `neogrove chat` command, which is a wrapper around the `grove-flow` tool's `flow run \u003cfile\u003e` command.\n-   `:GrovePlanExtract` calls `neogrove plan init --extract-all-from \u003cfile\u003e`, which uses `grove-flow` to initialize a plan and populate the first job from the specified file's content.\n\n---"
        },
        {
          "title": "Example 2: Managing Plans and Jobs",
          "content": "This example covers viewing existing plans and adding new jobs.\n\n1.  **Open the Plan Picker**\n\n    The `:GrovePlan` command opens a picker that lists available plans, their status, and job counts. It includes a preview pane that shows the detailed status of the selected plan.\n\n    *Text representation of the plan picker:*\n    ```\n    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Grove Plans â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”‚ \u003e ğŸ”                                                            â”‚\n    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n    â”‚   implement-a-new-caching-layer pending           1 jobs        â”‚\n    â”‚   refactor-user-api             completed        12 jobs        â”‚\n    â”‚   setup-ci-pipeline             in-progress       5 jobs        â”‚\n    â”‚                                                                 â”‚\n    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n    â”‚ Plan: refactor-user-api                                         â”‚\n    â”‚ Status: completed                                               â”‚\n    â”‚ Jobs: 12/12 completed                                           â”‚\n    â”‚                                                                 â”‚\n    â”‚ âœ… 010-map-out-api-endpoints.md                                  â”‚\n    â”‚ âœ… 020-update-auth-middleware.md                                 â”‚\n    â”‚ ...                                                             â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n    ```\n\n2.  **Add a Job with the Form UI**\n\n    The `:GroveAddJob` command opens a form in a floating window to define a new job for the currently active plan.\n\n    *Text representation of the \"Add Job\" form:*\n    ```\n    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Create New Job in 'refactor-user-api' â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”‚ Title:              Add rate limiting to endpoints                        â”‚\n    â”‚ Job Type:           agent                                                 â”‚\n    â”‚ Template:           [No template]                                         â”‚\n    â”‚ Prompt:             Use the new middleware to...                          â”‚\n    â”‚ Dependencies:       [020-update-auth-middleware.md]                       â”‚\n    â”‚ Model:              [Use plan default: claude-3-5-sonnet]                 â”‚\n    â”‚ Worktree:           feature/api-rate-limiting                           â”‚\n    â”‚                                                                           â”‚\n    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚\n    â”‚         [ Create Job ]            [ Cancel ]                              â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n    ```\n\n3.  **Add a Job with the Floating Terminal TUI**\n\n    The `:GroveAddJobTUI` command opens a floating terminal that runs `flow plan add -i \u003cplan\u003e`, which launches the interactive terminal UI for job creation from `grove-flow`.\n\n#### Comparison of Methods\n\n-   **Form UI (`:GroveAddJob`)**: Uses a Neovim-native UI to collect job details.\n-   **Terminal TUI (`:GroveAddJobTUI`)**: Runs the underlying `grove-flow` tool directly in a terminal.\n\n#### Mechanism\n\n-   `:GrovePlan` calls `neogrove plan list --json` to populate the picker.\n-   Adding a job via the form collects data and constructs a `neogrove plan add` command with the appropriate flags.\n-   `:GroveAddJobTUI` directly invokes the `flow` TUI.\n\n---"
        },
        {
          "title": "Example 3: The \"Target File\" Code-to-Chat Workflow",
          "content": "This workflow is for sending code snippets and questions to a central markdown file for analysis or refactoring.\n\n1.  **Set the Target File**\n\n    Open a markdown file and run the `:GroveSetTarget` command. This designates the file as the \"target\" for the session. This setting is persisted in `~/.grove/state.yml`.\n\n2.  **Select Code and Ask a Question**\n\n    Navigate to a source code file and visually select a block of code.\n\n    ```go\n    // main.go\n    func GetUser(id string) (*User, error) {\n        // ... implementation ...  \u003c-- visually select this function\n    }\n    ```\n\n3.  **Run the Workflow**\n\n    With the code selected, execute `:'\u003c,'\u003eGroveTextRun`. This performs the following actions:\n    1.  A popup appears, prompting for a question about the selected code.\n    2.  The selected code block and the question are appended to the target file.\n    3.  Neovim switches focus to the target file buffer.\n    4.  A silent `:GroveChatRun silent` command is initiated in the background.\n\n4.  **Monitor the Background Job**\n\n    While the AI processes the request, a spinner appears in the statusline, indicating that a job is running. This is enabled by adding `require('grove-nvim').status()` to a statusline configuration.\n\n    *Statusline with running job:*\n    ```\n    â ´ Grove | main.go | Go | UTF-8 | LF | ï…› 10:1\n    ```\n\n5.  **Check the Results**\n\n    When the spinner disappears, the background job is complete. The target file is updated with the AI's response.\n\n#### Use Cases\n\nThis workflow can be used for tasks such as:\n-   Requesting an explanation of a function.\n-   Pasting an error message and code to get debugging assistance.\n-   Asking for suggestions to refactor a piece of code.\n-   Generating documentation comments for a function or class.\n-   Creating unit tests for a selected function.\n\n#### Mechanism\n\nThis workflow uses `neogrove text select` and `neogrove text ask` to append content to the target file. It then triggers `neogrove chat`, which executes `flow run` on the updated target file. The background job and statusline integration are managed by the Lua plugin."
        }
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "\u003cimg src=\"./images/grove-neovim-readme.svg\" width=\"60%\" /\u003e\n\nGrove-nvim is a Neovim plugin that provides commands and workflows to interact with Grove tools, such as `grove-flow`. The plugin connects Neovim's text editing capabilities with Grove's plan management and code generation features.\n\n\u003c!-- placeholder for animated gif --\u003e",
      "subsections": [
        {
          "title": "Key Features",
          "content": "-   **In-Editor AI Chat**: Run interactive AI chat sessions directly on the current buffer using the `:GroveChatRun` command.\n\n-   **Plan Management**: Interact with `grove-flow` plans through a UI integrated into Neovim.\n    -   `:GrovePlan`: Opens an interactive picker to browse, preview, and manage existing plans.\n    -   `:GrovePlanInit`: Initializes a new plan directory with guided prompts for configuration.\n    -   `:GrovePlanExtract`: Creates a new plan by extracting content from the current markdown buffer, using its frontmatter or filename to suggest a plan name.\n\n-   **\"Code-to-Chat\" Workflow**: A process for using code snippets in AI conversations.\n    -   `:GroveSetTarget`: Designates a markdown file as the \"target\" for the current session.\n    -   `:'\u003c,'\u003eGroveTextRun`: Appends a visually selected block of code and a user prompt to the target file, then runs a silent chat session on that file.\n\n-   **Job Management**: Add jobs to plans using either a form-based UI (`:GroveAddJob`) for guided creation or a floating terminal TUI (`:GroveAddJobTUI`) for a more direct `flow` experience."
        },
        {
          "title": "How It Works",
          "content": "The plugin consists of two main components: a Lua plugin for Neovim and a Go command-line application named `neogrove`.\n\n1.  **Lua Plugin (`lua/` files)**: This component runs inside Neovim. It defines user commands (e.g., `:GrovePlan`, `:GroveChatRun`) and keybindings. It is responsible for creating the user interface elements, such as input prompts and pickers, and managing editor state.\n\n2.  **Go Binary (`neogrove`)**: When a user invokes a command, the Lua code executes the `neogrove` binary with appropriate arguments. This Go application serves as an interface and wrapper.\n\n3.  **Flow Execution**: The `neogrove` binary constructs and executes commands for the `flow` tool from the `grove-flow` project. It pipes standard input, output, and error streams between the `flow` process and the Neovim terminal or background job.\n\n### Installation\n\nInstall grove-nvim using the Grove meta-tool:\n\nThen add to your Neovim configuration. For example, with lazy.nvim:\n\nGrove-nvim requires the Grove ecosystem. See the [Grove Installation Guide](https://github.com/mattsolo1/grove-meta/blob/main/docs/02-installation.md) for setup instructions.",
          "code_blocks": [
            "grove install grove-nvim",
            "{ \"mattsolo1/grove-nvim\" }"
          ]
        }
      ]
    }
  }
}