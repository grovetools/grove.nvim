{
  "sections": {
    "configuration": {
      "title": "Configuration",
      "content": "This document provides instructions for installing, configuring, and using the keybindings for `grove-nvim`.",
      "subsections": [
        {
          "title": "1. Installation",
          "content": "The `grove-nvim` plugin requires the Grove ecosystem to be installed and available in your `PATH`.\n\n1.  **Install the plugin binary** using the Grove meta-tool:\n    ```bash\n    grove install grove-nvim\n    ```\n\n2.  **Add the plugin to your Neovim configuration.**\n\n    For `lazy.nvim`:\n    ```lua\n    { \"mattsolo1/grove-nvim\" }\n    ```\n\nThe plugin will be loaded automatically on startup."
        },
        {
          "title": "2. Configuration",
          "content": "### Plugin Setup\n\nThe `grove-nvim` plugin is designed to work after installation with no extra setup. It does not have or require a `setup()` function. Once loaded by your plugin manager, all commands and keybindings are available.\n\n### Statusline Integration\n\nThe plugin provides a status function to indicate when a background chat job is active. This is used for the `:GroveChatRun silent` command, which runs a job in the background and displays a spinner in the statusline instead of opening a terminal.\n\nThe function `require('grove-nvim').status()` returns a string containing a spinner animation and the text \"Grove\" when a job is running, and an empty string otherwise. It is implemented in `lua/grove-nvim/init.lua`.\n\n#### Lualine Example\n\nTo integrate with `lualine.nvim`, add the component to your configuration.\n\n\nThis configuration ensures the Grove component only appears in the statusline when a background chat job is active.",
          "code_blocks": [
            "-- ~/.config/nvim/lua/plugins/lualine.lua\n\nrequire('lualine').setup {\n  options = {\n    -- ... your other options\n  },\n  sections = {\n    -- ... other sections\n    lualine_x = {\n      -- Other components...\n      {\n        require('grove-nvim').status,\n        cond = function()\n          -- Only show the component when it's active\n          return require('grove-nvim').status() ~= ''\n        end,\n      },\n      'filetype',\n    },\n    -- ... other sections\n  },\n}"
          ]
        },
        {
          "title": "3. Keybindings",
          "content": "The following tables document the default keybindings provided by `grove-nvim`, sourced from `plugin/grove.lua`.\n\n### Plan Management\n\n| Keybinding       | Command                      | Description                               | Mode   |\n| ---------------- | ---------------------------- | ----------------------------------------- | ------ |\n| `\u003cleader\u003efp`     | `:GrovePlan`                 | Open the Grove Plan picker                | Normal |\n| `\u003cleader\u003efpx`    | `:GrovePlanExtract`          | Extract a new plan from the buffer        | Normal |\n| `\u003cleader\u003efpt`    | `:GrovePlanTUI`              | Open flow plan TUI (all plans)            | Normal |\n| `\u003cleader\u003efps`    | `:GrovePlanStatusTUI`        | Open flow plan status TUI (active plan)   | Normal |\n| `\u003cleader\u003efpl`    | `:GroveWorkspacePlansList`   | Show all workspace plans in table         | Normal |\n| `\u003cleader\u003ejn`     | `:GroveAddJob`               | Add job to active plan (Form UI)          | Normal |\n| `\u003cleader\u003eji`     | `:GroveAddJobTUI`            | Add job to active plan (TUI)              | Normal |\n\n### Chat \u0026 Flow\n\n| Keybinding       | Command                  | Description                        | Mode   |\n| ---------------- | ------------------------ | ---------------------------------- | ------ |\n| `\u003cleader\u003efc`     | `:GroveChatRun`          | Run an interactive chat session    | Normal |\n\n### Context \u0026 Configuration\n\n| Keybinding       | Command                      | Description                        | Mode   |\n| ---------------- | ---------------------------- | ---------------------------------- | ------ |\n| `\u003cleader\u003efe`     | `:GroveEditContext`          | Edit context rules                 | Normal |\n| `\u003cleader\u003efv`     | `:GroveContextView`          | Open cx view TUI                   | Normal |\n| `\u003cleader\u003efC`     | `:GroveConfigAnalyzeTUI`     | Open config analyze TUI            | Normal |\n\n### Sessions \u0026 Navigation\n\n| Keybinding       | Command                  | Description                        | Mode   |\n| ---------------- | ------------------------ | ---------------------------------- | ------ |\n| `\u003cleader\u003efs`     | `:GroveSessionize`       | Open gmux sessionize TUI           | Normal |\n| `\u003cleader\u003efk`     | `:GroveGmuxKeymap`       | Open gmux keymap manager TUI       | Normal |\n| `\u003cleader\u003efh`     | `:GroveHooksSessions`    | Browse grove-hooks sessions        | Normal |\n\n### Workspace \u0026 Monitoring\n\n| Keybinding       | Command                  | Description                        | Mode   |\n| ---------------- | ------------------------ | ---------------------------------- | ------ |\n| `\u003cleader\u003efw`     | `:GroveWorkspaceStatus`  | Show workspace status table        | Normal |\n| `\u003cleader\u003efl`     | `:GroveLogsTUI`          | Open grove logs TUI                | Normal |\n| `\u003cleader\u003efn`     | `:GroveNBManage`         | Open notebook manager TUI          | Normal |\n\n### Release Management\n\n| Keybinding       | Command                  | Description                        | Mode   |\n| ---------------- | ------------------------ | ---------------------------------- | ------ |\n| `\u003cleader\u003efrl`    | `:GroveReleaseTUI`       | Open grove release TUI             | Normal |\n\n### Target File Workflow\n\nThese keybindings operate on visually selected text and require a target file to be set with `:GroveSetTarget`.\n\n| Keybinding       | Command                  | Description                               | Mode   |\n| ---------------- | ------------------------ | ----------------------------------------- | ------ |\n| `\u003cleader\u003efq`     | `:'\u003c,'\u003eGroveText`        | Append selection and ask a question       | Visual |\n| `\u003cleader\u003efr`     | `:'\u003c,'\u003eGroveTextRun`     | Append selection, ask, and run chat       | Visual |"
        }
      ]
    },
    "examples": {
      "title": "Examples",
      "content": "This document provides practical examples for using `grove-nvim`, demonstrating its main workflows for AI-assisted development within Neovim.",
      "subsections": [
        {
          "title": "Example 1: Interactive Chat and Plan Creation",
          "content": "This example demonstrates starting with an interactive session in a markdown file and converting it into a Grove plan.\n\n1.  **Start an Interactive Chat Session**\n\n    The `:GroveChatRun` command runs an interactive `flow chat` session on the current buffer.\n\n    ```markdown\n    ---\n    title: \"Implement a new caching layer\"\n    ---\n\n    # Brainstorming: New Caching Layer\n\n    Let's design a caching layer for our application. It should use Redis and have a clear API for getting, setting, and invalidating cache keys.\n    ```\n\n    Running `:GroveChatRun` opens a new terminal split within Neovim. The content of the markdown file is used as the initial context. After the session, the file is updated with the full transcript.\n\n2.  **Convert the Chat into a Plan**\n\n    The `:GrovePlanExtract` command creates a development plan from the current buffer's content. It prompts for a plan name, suggesting one based on the `title` field from the markdown frontmatter. If no title is found, it uses the buffer's filename as a fallback.\n\n    ```\n    New Plan Name (from buffer): implement-a-new-caching-layer\n    ```\n\n3.  **Resulting Behavior**\n\n    After confirming the name, `grove-nvim` creates a new plan directory (e.g., `.grove/plans/implement-a-new-caching-layer/`). The content of the markdown file is used to create the first job in the plan, `010-implement-a-new-caching-layer.md`.\n\n#### Mechanism\n\n-   `:GroveChatRun` executes the `grove-nvim chat` command, which is a wrapper around the `grove-flow` tool's `flow run \u003cfile\u003e` command.\n-   `:GrovePlanExtract` calls `grove-nvim plan init --extract-all-from \u003cfile\u003e`, which uses `grove-flow` to initialize a plan and populate the first job from the specified file's content.\n\n---"
        },
        {
          "title": "Example 2: Managing Plans and Jobs",
          "content": "This example covers viewing existing plans and adding new jobs.\n\n1.  **Open the Plan Picker**\n\n    The `:GrovePlan` command opens a picker that lists available plans, their status, and job counts. It includes a preview pane that shows the detailed status of the selected plan.\n\n    *Text representation of the plan picker:*\n    ```\n    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Grove Plans â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”‚ \u003e ğŸ”                                                            â”‚\n    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n    â”‚   implement-a-new-caching-layer pending           1 jobs        â”‚\n    â”‚   refactor-user-api             completed        12 jobs        â”‚\n    â”‚   setup-ci-pipeline             in-progress       5 jobs        â”‚\n    â”‚                                                                 â”‚\n    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n    â”‚ Plan: refactor-user-api                                         â”‚\n    â”‚ Status: completed                                               â”‚\n    â”‚ Jobs: 12/12 completed                                           â”‚\n    â”‚                                                                 â”‚\n    â”‚ âœ… 010-map-out-api-endpoints.md                                  â”‚\n    â”‚ âœ… 020-update-auth-middleware.md                                 â”‚\n    â”‚ ...                                                             â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n    ```\n\n2.  **Add a Job with the Form UI**\n\n    The `:GroveAddJob` command opens a form in a floating window to define a new job for the currently active plan.\n\n    *Text representation of the \"Add Job\" form:*\n    ```\n    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Create New Job in 'refactor-user-api' â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n    â”‚ Title:              Add rate limiting to endpoints                        â”‚\n    â”‚ Job Type:           agent                                                 â”‚\n    â”‚ Template:           [No template]                                         â”‚\n    â”‚ Prompt:             Use the new middleware to...                          â”‚\n    â”‚ Dependencies:       [020-update-auth-middleware.md]                       â”‚\n    â”‚ Model:              [Use plan default: claude-3-5-sonnet]                 â”‚\n    â”‚ Worktree:           feature/api-rate-limiting                           â”‚\n    â”‚                                                                           â”‚\n    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚\n    â”‚         [ Create Job ]            [ Cancel ]                              â”‚\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n    ```\n\n3.  **Add a Job with the Floating Terminal TUI**\n\n    The `:GroveAddJobTUI` command opens a floating terminal that runs `flow plan add -i \u003cplan\u003e`, which launches the interactive terminal UI for job creation from `grove-flow`.\n\n#### Comparison of Methods\n\n-   **Form UI (`:GroveAddJob`)**: Uses a Neovim-native UI to collect job details.\n-   **Terminal TUI (`:GroveAddJobTUI`)**: Runs the underlying `grove-flow` tool directly in a terminal.\n\n#### Mechanism\n\n-   `:GrovePlan` calls `grove-nvim plan list --json` to populate the picker.\n-   Adding a job via the form collects data and constructs a `grove-nvim plan add` command with the appropriate flags.\n-   `:GroveAddJobTUI` directly invokes the `flow` TUI.\n\n---"
        },
        {
          "title": "Example 3: The \"Target File\" Code-to-Chat Workflow",
          "content": "This workflow is for sending code snippets and questions to a central markdown file for analysis or refactoring.\n\n1.  **Set the Target File**\n\n    Open a markdown file and run the `:GroveSetTarget` command. This designates the file as the \"target\" for the session. This setting is persisted in `~/.grove/state.yml`.\n\n2.  **Select Code and Ask a Question**\n\n    Navigate to a source code file and visually select a block of code.\n\n    ```go\n    // main.go\n    func GetUser(id string) (*User, error) {\n        // ... implementation ...  \u003c-- visually select this function\n    }\n    ```\n\n3.  **Run the Workflow**\n\n    With the code selected, execute `:'\u003c,'\u003eGroveTextRun`. This performs the following actions:\n    1.  A popup appears, prompting for a question about the selected code.\n    2.  The selected code block and the question are appended to the target file.\n    3.  Neovim switches focus to the target file buffer.\n    4.  A silent `:GroveChatRun silent` command is initiated in the background.\n\n4.  **Monitor the Background Job**\n\n    While the AI processes the request, a spinner appears in the statusline, indicating that a job is running. This is enabled by adding `require('grove-nvim').status()` to a statusline configuration.\n\n    *Statusline with running job:*\n    ```\n    â ´ Grove | main.go | Go | UTF-8 | LF | ï…› 10:1\n    ```\n\n5.  **Check the Results**\n\n    When the spinner disappears, the background job is complete. The target file is updated with the AI's response.\n\n#### Use Cases\n\nThis workflow can be used for tasks such as:\n-   Requesting an explanation of a function.\n-   Pasting an error message and code to get debugging assistance.\n-   Asking for suggestions to refactor a piece of code.\n-   Generating documentation comments for a function or class.\n-   Creating unit tests for a selected function.\n\n#### Mechanism\n\nThis workflow uses `grove-nvim text select` and `grove-nvim text ask` to append content to the target file. It then triggers `grove-nvim chat`, which executes `flow run` on the updated target file. The background job and statusline integration are managed by the Lua plugin."
        }
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "`grove.nvim` is a Neovim plugin that integrates the Grove CLI ecosystem into the editor. It provides a Lua interface for orchestrating AI workflows, managing context, and navigating workspaces by wrapping the underlying `grove` binaries.",
      "subsections": [
        {
          "title": "Core Mechanisms",
          "content": "**Hybrid Architecture**: The plugin consists of a Lua frontend and a Go binary. The Lua layer handles UI elements (floating windows, virtual text, inputs), while the Go binary acts as a bridge, constructing and executing commands for `flow`, `cx`, and `tend`.\n\n**Terminal Wrapping**: Interactive CLI tools (like `flow plan tui`, `cx view`, `nb tui`) are executed inside Neovim floating windows or splits. This allows usage of the full TUI capabilities without leaving the editor context.\n\n**Tool Status**: The plugin polls metadata from `flow plan status --json` and `cx stats` to render real-time feedback via a native status bar or Lualine components.\n\n**Internal Discovery**: The embedded Go binary utilizes `grove core` libraries directly to perform workspace discovery and alias resolution (`resolve-aliases`), ensuring consistent path handling with the rest of the ecosystem."
        },
        {
          "title": "Features",
          "content": "### Flow Orchestration\n*   **Chat Execution**: `:GroveChatRun` executes `flow run` on the current Markdown buffer. It pipes output to a terminal window or handles headless execution with status indicators.\n*   **Plan Management**: `:GrovePlan` opens a picker (via `snacks.nvim`) to browse, filter, and manage plans. `:GroveAddJob` provides a form-based UI for appending jobs to the active plan.\n*   **Visual Indicators**: Renders virtual text in Markdown files to distinguish user turns, LLM responses, and running states.\n\n### Context Management\n*   **Rule Editing**: Provides syntax highlighting and virtual text statistics for `.grove/rules` files. It executes `cx stats --per-line` to display token counts and file matches next to each rule.\n*   **Alias Resolution**: The rules editor supports `gf` (go to file) on `@alias` directives by resolving them via `cx resolve`.\n*   **Autocompletion**: Integrates with `blink.cmp` to provide completions for:\n    *   **Aliases**: `@alias:` paths resolved from the workspace via `cx workspace list`.\n    *   **Git Repos**: Remote repository paths for `git:` aliases via `cx repo list`.\n    *   **Templates**: Available job templates via `flow plan templates list`.\n\n### File Marking\nThe `:GroveMarkFile` command adds the current buffer to a persistent `.grove/marks` list. The plugin automatically syncs this list into the `.grove/rules` file using aliases, allowing rapid context manipulation without manual rule editing.\n\n### Testing Integration\n`:GroveRunTest` executes the `tend` test scenario defined under the cursor. It extracts the scenario name from the Go file and runs `tend run --debug-session \u003cname\u003e` in a floating window.\n\n### Text Interaction\n`:GroveText` captures visually selected text and prompts for a user question. It appends both to a target chat file and optionally executes the run immediately (`:GroveTextRun`), facilitating \"ask about code\" workflows."
        },
        {
          "title": "Integrations",
          "content": "`grove.nvim` serves as the editor layer for the following tools:\n\n*   **`flow`**: Manages the lifecycle of chat sessions and plans. The plugin reads job statuses via JSON output and executes plan modifications.\n*   **`cx`**: Used for context analysis. The plugin visualizes `cx stats` data, uses `cx resolve` for navigation, and `cx workspace list` for autocompletion.\n*   **`tend`**: Executes specific test scenarios identified by the cursor position in Go test files.\n*   **`nav`** / **`gmux`**: `:GroveSessionize` wraps `gmux sz` to switch tmux sessions from within Neovim.\n*   **`hooks`**: `:GroveHooksSessions` displays the active session history TUI.\n*   **`nb`**: `:GroveNBBrowse` opens the notebook TUI for knowledge base navigation.\n*   **`grove`**: Wraps the `release` and `logs` TUIs for ecosystem management.\n*   **`core`**: The plugin's binary imports `grove-core` packages to replicate workspace discovery logic for internal operations."
        }
      ]
    }
  }
}